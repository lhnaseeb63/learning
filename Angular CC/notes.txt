Task Tracker

Angular 11:
- Front-end JS framework
- Single-page apps
- Like with react and view, typically runs on the client
- Typically used in MEAN stack fullstack apps
- Angular 2 - 11 are the same but with updates
- AJS (Angular 1) is completely different framework

Advantages
- More full-featured than react or view- routing, http clients, dependency injection, 
- Steeper learning curve
- Uses typescript by default but don't have to know it to work with Angular
- Uses RxJS library that allow us to use observables, great for asynch programming
- Test-friendly 
- Not as popular in react, but used in the large enterprise business world

Angular Components
- Component driven, like any other front-end framework
- Components are reusable
- In our task tracker, will be building the following components: 
--> Header
--> Open and Close button
--> Add Task 
--> Display tasks 
--> Each individual task is also its own component
--> footer
- Will use router to get to the about page and back to the home page

Angular Services
- Increase modularity and reusability
- Intended to be used across components 
- deals with one task each 

Angular CLI 
- run a local dev server
- build out static assets for production 
- install on command line 
- use ng new app-name to generate app
- when you're ready to build can run ng build which creates a dist folder that you can upload to your host
- commands can create boiler plate

Let's Learn Angular!
- Almost everything we create goes in the src folder
- Can add cdns and css in angular.json file
--> can change output folder from dist to public at deployment in there as well
- Everything in the index.html is loaded into <app-root></app-root>, like <ui-view>
- Even if we don't know typescript, it's best to use the .ts extension instead of .js
- main.ts is the angular entry point
    --> import app modules (forms, http, AppModule )
    --> Can see AppModule getting bootstrapped. 

-AppModule is in the app folder (app.module.ts)
    --> NgModule is brought in from angular/core
    --> When you create a component (App component is root component) it is put in declarations 
    @NgModule({
        declarations:[
            AppComponent,
            OurComponentHere
            /*Components*/
        ],
        imports: [
            BrowserModule
            /*Modules*/
        ],
        providers:[],
        bootstrap: [AppComponent]
    })
    So our component is imported and declared in this file. 
    When we create components in the CLI it will do this for us automatically
    Whenever you use a module like browserModule, formsModule, httpModule, it goes in imports. 
    Global Services go into providers
    lastlly bootstrap which in our case we are bootstrapping the main app component

- When you create a component you are generally going to have 4 files (src/app)
    --> TS file, main class with properties, methods, specifies template and style sheet
    --> <> HTML file, which is your template
    --> # CSS file
    --> spec file for testing, which we don't touch on in this course. 

- With every component we are going to have the following: (src/app/app.component.ts)
    --> importing component from the core
    --> then declaration with 3 items
    1. selector, the html tag you are going to use to embed your component
    2. tempalteUrl, the html file you're using
    3. styleUrls, can have more than one css here 
    --> Then you have your class where you put any properties and methods
    --> not using TS by default but he recommends defining your types. 
    --> To show properties we save to the componnet (like the controller in AJS) we use string interpolation
        --> in the app.component.html : {{ property }}
        --> can also do simple math: {{ 1 +  5 }}
        --> can also apply functions, ternary, any js expression: {{ property.toUpperCase() }}

Styling
- style.css is for global styling.
- copied from his repo

Creating our first component
- ng generate component components/header
- couple extra things:
    --> There is a constructor in the class. Runs whenever object is initialized 
    --> ngOnInit() is a lifecycle method. 
        --> If you want a method to run when the component loads you would put 
        it in here ( ex.http request ).
    --> html, let's embed into main app component 
    --> Use the selector from the header component declaration 
            @Component({
                selector: 'app-header',
                templateUrl: './header.component.html',
                styleUrls: ['./header.component.css']
                })
        in app.component.html: <app-header><app-header>

Resuing components
- ng generate component components/button
- in header.component.html use <app-button><app-button>
- want to pass in color and the text for a button
    header.component.html:
    <app-button color="green" text="Add"></app-button>
- now we go into the button class and import the Input module.
    -->button.component.ts
    --> then we use  @Input() text: string;
                     @Input() color: string;
        to initialize our properties.

    button.component.html
    <button  [ngStyle]="{'background-color':color}" class="btn">{{text}}</button>
-Voila!

Adding Events
- using our button example
- just add '(event)' and set the method
    --> button.component.html
        --> (click) = "onClick()"
        --><button  [ngStyle]="{'background-color':color}" class="btn" (click)="onClick()">{{text}}</button>
        --> define the onClick() method in the class 
            --> button.component.ts
- We don't want this button to perform just the one function. 
We want it to do different methods, so we will use an 
event emitter and output the event. 
- We do this by bringing in the Output and EventEmitter modules
    --> @Output() btnClick = new EventEmitter();
    --> onClick() {
            this.btnClick.emit();
        }
        --> Not going to do anything. It's just emitting. 
- Then we go to the html tag for the button 
in header.component.html and pass in the event  
    --> <app-button color="green" text="Add" (btnClick)="toggleAddTask"></app-button>
- Then we define toggleAddTask in our header.component.ts
- Button is now reusable and can be embedded anywhere with a 
custom color, custom text, and custom function when it's clicked.

Starting to make tasks
- from json server. Like a fake REST API we can create and run 
locally
- app/mock-tasks.ts
    --> export an array of objects each having an id, text, date,
    and reminder boolean. 
- going to create an interface for a task
    --> app/Task.ts
    --> create inferface (like a class but we can't 
    add or remove from the template we define)
    --> In mock-tasks.ts we import Task.ts and define our
    mock tasks as type: Task.
    --> We say Task[] because we are creating an array of Task
    objects.  
- Now we make our task component with our 4 files
    --> ng generate component components/tasks
- Ultimately the tasks are going to come from our backend (JSON SERVER)
- For now we just bring them in from that file.
    -->import { Task } from '../../Task';
    -->import { TASKS } from '../../mock-tasks';
- Then in the class we define a local 'tasks' property that 
we define as the TASKS array from mock-tasks.ts and as type
Task from Task.ts.
-Then in our html tag we can loop over using *ngFor
    --> <p *ngFor = "let task of tasks">{{ task.text }}</p>
- We don't want to just list everything in a <p></p>, 
we want each task item in its own component. 
    --> <app-task-item *ngFor = "let task of tasks" [task]="task"></app-task-item>
    --> [task]="task" 
        --> We want to pass in a property of task equal to the 
        task from that iteration. 
        --> Each task is sent from task.component.ts to task-item.component.ts
    --> make new component
        --> ng generate component components/tasks-item
        --> import Task interface and input modules
        --> save each task as type 'Task'
        --> Print from tasks.html
- For each task we want to have a delete icon so we are 
adding angular font awesome using: 
    --> ng add @fortawesome/angular-fontawesome@<version>
    --> Then in the component we want to use the icon in we have to
    import then assign the icon as a property in the class.
        -->import { faCoffee } from '@fortawesome/free-solid-svg-icons';
        -->faCoffee = faCoffee;
    --> Then we use the fa-icon tag in the component html
        --> <fa-icon [icon]="faCoffee"></fa-icon>

Creating Services
- At this point, we know how to create components, add properties,
create an event, and how to use directives like ngStyle.  
- At the moment, we are directly importing the Tasks from the 
mock-tasks.ts file into the tasks.ts file. We are now
going to create a service that will bring it in instead and call
the service from the class. 
- Can create a service from the CLI. 
    --> ng generate service services/task
- A service is a class
- Going to copy both imports from tasks.component.ts to 
tasks.service.ts.
- In the service we are going to create a function called 
getTasks that returns an array of Tasks (the type from the interface)
- In the componenet we import the service, then add it as an 
argument in the constructor. 
    --> constructor(private taskService: TaskService){}
        --> private means we will only 'taskService' from here
        --> 'taskService' is the local instance of the service 
- We can then call any function in the service from
ngInit by using 'this.taskService.fucntion()'
    --> ngOnInit(): void {
            this.tasks = this.taskService.getTasks()
        }
    --> So we assign the empty task array with whatever the service 
    returns. 
- Instead of this.tasks, let's make it an observable
    --> An observable is better when we are dealing with 
    asynchronous data, such as when you're fetching from a server
    or just bringing a file in and setting it to that. 
    --> need to bring in from the rxjs library the Observable 
    and of libraries to task.service.ts
        --> import {Observable, of} from 'rxjs';
    --> in the function we change the return type of Task[] to
    Observable <Task[]>
    --> getTasks(): Observable <Task[]> {
            const tasks = of( TASKS );
            return tasks;
        }
    --> the of() is what converts it into an observable.
    --> We get an error from the component file because we 
    can't be using this.tasks = this.taskService.blah 
    anymore because we are now deailing with observables. We
    need to subscribe to the observable so you can watch it. 
        --> ngOnInit(): void {
                this.taskService.getTasks().subscribe((tasks)=>{
                this.tasks = tasks;
            });
        --> Like with promises you can put a callback functon in the 
        .then(), we here put a callback in .subscribe()
        --> Same result, but it works differently behind the scenes. 
- In real like you'll be working with a server and will be using the
Angular HTTP client which returns Observables. 

JSON Server and Observables
- Creating a full fake REST API (not for deployment)
- In Summary:
    - Create a db.json file in root
        - Everything needs to be in JSON format
    - Can add different collections (in our case tasks)
        - essentially our database
    - then we run a script that will run the JSON server
    and watch the db.json file 
    - Can make get, put, post, patch, and delete requests
- Getting started Now
-npm install json-server
    - not running it globally but will run a script to get it started
    - in package.json go to "scripts" :{
        "server": "json-server --watch db.json --port 5000"
    }
- With db.json created can run the server
    --> npm run server
    --> localhost:5000/tasks
- Now with a server and db we need an api to make requests
- In task.service.ts    
    --> import { HttpClient, HttpHeaders } from '@angular/common/http';
- Have to add the HttpClientModule as a module
- app.module.ts
    --> import { HttpClientModule } from '@angular/common/http';
    --> keeping modules on top and componenets below. Cleaner. 
    --> Go down to imports and add the HttpClientModule
    --> Any file that we need to import needs to be declared in this 
    file, essentially before it can be used through the rest of the 
    program.
- Back to task.service.ts
    - adding a property for the URL that we are hitting
    - Just like when we had to add our Task service as a parameter in 
    the constructor of the task component, we  have to add the
    HTTP stuff as a parameter to our task service. 
        --> constructor(private http:HttpClient) { }
        --> now we can use this.http.methodWeWant
    --> getTasks(): Observable <Task[]> {
            return this.http.get<Task[]>(this.apiURL);
        }
    - now being brough in from an http request rather than a local 
    file. 
    - assigning the observable to type Task

Learning to Delete Tasks
- First we need to create an event when the user clicks the 'x' button
- in tasks-item.component.html
    --> (click)="onDelete(task)"
    --> passes in the task
- in tasks-item.component.ts
    -->  onDelete(task:Task) {
            console.log(task);
        }
- Want to have the delete functionality written out in task.component.ts 
as the parent of tasks-items. 
    --> remember if we look at tasks.component.html we have the 
    tasks-item embedded there. 

